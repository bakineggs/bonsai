Bonsai Programming Language
^^^^^^^^^^^^^^^^^^^^^^^^^^^
This is a work in progress. There is not yet a fully working implementation (although a subset of the language has been implemented so far).

Bonsai is a programming language in which you define rules to match patterns in a tree and transform the matched part of the tree. These rules are applied over and over until no rules match anywhere in the tree.

Trees are represented by indented lists. A node's children are indented 2 more spaces than their parent. The children can be either unordered or ordered. Using a single colon after the node's label denotes that the children are an unordered multiset. Using two colons after the node's label denotes that the children are an ordered list.

Nodes can either have children or have a value associated with them. Values can be either integers, decimals, or strings.

A rule is defined by showing the part of the tree that must be matched and should be transformed. Certain nodes can have operators preceding their label which modify how this node affects whether or not the rule matches and how the tree should be transformed. There are 3 operators: !, +, and -. The ! operator says that if this node matches, then the rule does not match. The + operator says that this node need not match for this rule to match and that the node will be created when the tree is transformed. The - operator says that this node must match for this rule to match and that the node will be removed when the tree is transformed.

The special label ^ denotes the root of the tree.

Example: Stable Marriage Problem
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Here is an example of how you can use Bonsai to solve the stable marriage problem (http://en.wikipedia.org/wiki/Stable_marriage_problem).

# Create a node below the root to list the singles available. This is the input to our problem.
^:
  !Available:
  +Available:
    Man:
      Name: "Bob"
      Needs to Propose To::
        Woman: "Vanessa"
        Woman: "Alice"
    Man:
      Name: "Joe"
      Needs to propose to::
        Woman: "Alice"
        Woman: "Vanessa"
    Man:
      Name: "Dave"
      Needs to propose to::
        Woman: "Alice"
        Woman: "Vanessa"
    Woman:
      Name: "Alice"
      Will accept proposals from::
        Man: "Bob"
        Man: "Dave"
        Man: "Joe"
    Woman:
      Name: "Vanessa"
      Will accept proposals from::
        Man: "Bob"
        Man: "Joe"
        Man: "Dave"

# Pair a man with his most preferred woman if she is available.
Available:
  -Man: M
    Needs to propose to::
      Woman: N
  -Woman: W
    Name: N
+Engaged:
  +Man: M
  +Woman: W

# A man proposes to a woman who prefers him more than the man she is currently engaged to.
Engaged:
  -Man: Dumped
    Name: Loser
  +Man: Newly engaged
  Woman:
    Will accept proposals from::
      *:*
      Man: Winner
      *:*
      Man: Loser
Available:
  -Man: Newly engaged
    Name: Winner
  +Man: Dumped

# A man proposes to a woman who prefers to stick with the man she is engaged to.
Engaged:
  Man:
    Name: Winner
  Woman:
    Will accept proposals from::
      *:*
      Man: Winner
      *:*
      Man: Loser
Available:
  Man:
    Name: Loser
    Needs to propose to::
      -Woman:

For Writing Languages
^^^^^^^^^^^^^^^^^^^^^
Bonsai is primarily designed for writing programming languages. By representing the AST, environment, memory, etc. in a single tree, you can define the semantics of a language by writing rules to transform the tree.

Here are some rules that could be part of an interpreter of some language:

# spawn new thread (see see https://gist.github.com/369171 for similar k-framework version)
Thread:              # node must be matched
  K::                # node must be matched, the :: means that children are ordered (default is unordered)
    -Spawn:=         # node must be matched, the - means that this node will be removed, the := means all children must be matched
      *:* S          # makes S a variable that is any number of any kind of node (makes a variable because it's a matched node)
  Env: E
+Thread:             # node not matched against, the + means this node will be added
  K::
    *: S             # references the variable S (because it's inside a new node)
  Env: E

# purge a finished thread
-Thread:
  K:=                # the = means an exact match (not containing any unmatched nodes), so this matches a "K" node with no children

# wait for all threads to finish or rendezvous
Threads:=            # all child nodes must match for this rule to apply
  Thread:*           # the * means that there can be any number of these nodes
    K::
      -Rendezvous:

# wait for another thread to finish
Thread:
  K::
    -Join:
      Integer: I
!Thread:             # this node must not match
  Id: I

# integer addition
-Plus:
  Integer: A
  Integer: B
+Integer: < A + B    # the < means do a computation (with the ability to call user-defined functions) - syntax and use has changed since this example was written

# decimal addition
-Plus:
  Decimal: A
  Decimal: B
+Decimal: < A + B

# mixed addition
-Plus:
  Integer: A
  Decimal: B
+Decimal: < A + B

# remove an argument for evaluation (all args must start inside an "unevaluated" node)
K::
  +*: A
  +Restore:
    Plus:
      -Unevaluated:
        *: A
      +Context:

# reinsert evaluated integer
K::
  -Integer: I
  -Restore:
    Plus:
      -Context:
      +Integer: I

# reinsert evaluated decimal
K::
  -Decimal: A
  -Restore:
    Plus:
      -Context:
      +Decimal: A
